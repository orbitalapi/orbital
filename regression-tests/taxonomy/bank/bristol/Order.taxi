import bank.common.BankTraderBrokerLogin

import bank.common.organisation.Desk
import bank.common.counterparty.CounterpartyName
import bank.common.counterparty.BankLegalEntityIdentifier
import bank.common.price.PriceType
import bank.common.organisation.Desk
import bank.common.OrderBankDirection      // why is this in common and not in orders?

import bank.orders.VenueOrderStatus
import bank.orders.OrderType
import bank.orders.CumulativeQuantity
import bank.orders.RemainingQuantity
import bank.orders.DisplayedQuantity
import bank.orders.RequestedQuantity
import bank.orders.PriceAmount
import bank.orders.TraderId
import bank.orders.OrderCurrencyCode
import bank.orders.OrderEventDateTime
import bank.orders.OrderEventDate
import bank.orders.MIC
import bank.orders.Order
import bank.orders.OrderId
import bank.orders.TimeInForce

import bank.instrument.InstrumentId
import bank.instrument.InstrumentIdentifierType
import bank.instrument.UnderlyingInstrumentId
import bank.instrument.MaturityDateDate
import bank.instrument.ExpiryDate
import bank.instrument.NominalValue


import bank.finance.CDR
import bank.finance.SingleCDR


namespace bank.bristol {

    // types to be used only for this report
    //
    type StringField inherits String
    type DecimalField inherits Decimal
    type IntField inherits Int
    

    model CBOrderReport inherits Order {    
        
        // the unique id of this order
        //
        orderId: bank.orders.OrderId?

        // these fields are blank because they are not available in broker files
        //
        sequenceNumber: bank.bristol.StringField?
        orderVersion: bank.bristol.StringField?
        orderVersionKey: bank.bristol.StringField?
        
        // as specified in KDB Elect Bond Orders General Specification 2.4
        //
        productKey: bank.bristol.StringField by concat(this.instrumentId, "_", this.origCurrCd, "_", this.venueCd)

        // these fields are blank because they are not available in broker files
        //
        strategyProductkey: bank.bristol.StringField?
        strategyType: bank.bristol.StringField?
        
        // temp variable not to be output but required by when clauses
        //
        tempDirection: bank.common.OrderBankDirection?
        
        // convert from taxonomy to BORK format
        //
        directionCd: bank.bristol.StringField? by when(this.tempDirection) {
            "BankBuys" -> "Buy"
            "BankSell" -> "Sell"
            else -> "Unknown"
        }
        
        // temp variable not to be output but required by when clauses
        //
        tempOrderTerm: bank.orders.TimeInForce?
        
        // convert from taxonomy to BORK format
        //
        orderTerm: bank.bristol.StringField? by when(this.tempOrderTerm) {
            "GTT" -> "GTD"
            "Day" -> "GFD"
            "ATC" -> "GFD"
            "PlatformSpecified" -> 'GFD'
            else -> tempOrderTerm
        }

        // goodTillBettered not accepted by bristol
        //
        tempOrderType: bank.orders.OrderType?
        orderType: bank.bristol.StringField? by when(this.tempOrderType){
            "GoodTillBettered" -> "Limit"
            else -> tempOrderType
        }
        
        exchangeCd: bank.orders.MIC?
        
        venueCd: bank.orders.MIC?
        
        businessDate: bank.orders.OrderEventDateTime?  (@format = "dd/MM/yyyy")

        orderEntryGlobalDateTime: bank.orders.OrderEventDateTime? (@format = "dd/MM/yyyy HH:mm:ss.SSSSSSSSS")

        // this is blank because we cannot derive local timezone
        //
        orderEntryLocalDateTime: bank.bristol.StringField?
        
        orderGlobalDateTime: bank.orders.OrderEventDateTime? (@format = "dd/MM/yyyy HH:mm:ss.SSSSSSSSS")

        // this is blank because we cannot derive the local timezone
        //
        orderLocalDateTime: bank.bristol.StringField?
        
        reportedDate: bank.orders.OrderEventDateTime? (@format = "dd/MM/yyyy")

        // this is blank because it is blank in the BORK output
        //
        baseCurrCd: bank.bristol.StringField?
        
        // tmp variable to allow mw to assign other fields to 0.0!
        //
        tmpZero: bank.bristol.DecimalField? by default(0)

        // assumptions are only get stops or limits
        //
        tmpPriceAmount: bank.orders.PriceAmount?
        tmp2PriceAmount: bank.bristol.DecimalField? by when {
            this.tmpPriceAmount = 0.0 -> null
            else -> tmpPriceAmount
        }

        baseCurrLimitPrice: bank.bristol.DecimalField? by when (this.orderType){
            "Stop" -> tmpZero
            else -> tmp2PriceAmount
        }

        baseCurrStopPrice: bank.bristol.DecimalField? by when (this.orderType){
            "Stop" -> tmp2PriceAmount
            else -> tmpZero
        }

        origCurrLimitPrice: bank.bristol.DecimalField? by when (this.orderType){
            "Stop" -> tmpZero
            else -> tmp2PriceAmount
        }
        
        // this is blank because it is blank in the BORK output
        //
        accountKey: bank.bristol.StringField?

        // the profit centre
        //
        aggUnitCd: bank.finance.SingleCDR?

        deskId: bank.common.organisation.Desk?

        // the broker legal entity
        //
        legalEntityId: bank.common.counterparty.BankLegalEntityIdentifier?

        // this is blank because it cannot be derived from broker files
        //
        portfolioManagerKey: bank.bristol.StringField?
        
        traderId: bank.orders.TraderId? //Obtained from lookup
        cacibTraderBrokerLogin: BankTraderBrokerLogin? //Broker specific Trader value
        traderKey: StringField? by when{
            this.traderId = null -> cacibTraderBrokerLogin
            else -> traderId    
        }

        // this is blank because it is blank in the BORK output
        //
        baseCurrOrderPrinAmount: bank.bristol.StringField?
        fxCounterCurrPrinAmount: bank.bristol.StringField?

        tempNominalValue : bank.instrument.NominalValue?

        tempRequestedQuantity : bank.orders.RequestedQuantity?
        tempRequestedUnitQuantity : bank.orders.RequestedUnitQuantity?

        // as the requested quatity type is not a String we cannot put : this.tempRequestedQuantity = ""
        origCurrOrderPrinAmount: bank.bristol.DecimalField? by when {
            this.tempRequestedQuantity = null  -> (tempRequestedUnitQuantity * tempNominalValue)
            else -> tempRequestedQuantity
        }
       

        // this is blank because it is blank in the BORK output
        //
        baseVolume: bank.bristol.StringField?

        tempLeavesQuantity : bank.orders.RemainingQuantity?
        tempLeavesUnitQuantity : bank.orders.RemainingUnitQuantity?
        
        leavesQuantity: bank.bristol.DecimalField? by when {
            this.tempLeavesQuantity = null  -> (tempLeavesUnitQuantity * tempNominalValue)
            else -> tempLeavesQuantity
        }
        
        quantity: bank.bristol.DecimalField? by when {
            this.tempRequestedQuantity = null  -> (tempRequestedUnitQuantity * tempNominalValue)
            else -> tempRequestedQuantity
        }
        
        // these are blank because they are blank in the BORK output
        //
        notionalValue: bank.bristol.StringField?
        notionalValue2: bank.bristol.StringField?
        
        // temp variable not to be output but required by when clauses
        //
        tempVenueOrderStatus:  bank.orders.VenueOrderStatus?

        // convert from taxonomy to BORK format
        //
        transactionActionCd: bank.bristol.StringField? by when(this.tempVenueOrderStatus) {
            "New" -> "NEW"
            "PartiallyFilled" -> "MOD"
            "Filled" -> "MOD"
            "DoneForDay" -> "MOD"
            "Canceled" -> "CAN"
            "Replaced" -> "MOD"
            "PendingCancel" -> "MOD"
            "Stopped" -> "CAN"
            "Rejected" -> "CAN"
            "Suspended" -> "CAN"
            "PendingNew" -> "MOD"
            "Calculated" -> "MOD"
            "Expired" -> "CAN"
            "AcceptedForBidding" -> "MOD"
            "PendingReplaced" -> "MOD"
            "ChangeByMember" -> "MOD"
            "ChangeByMarketOps" -> "MOD"
            else -> "MOD"
        }

        // convert from taxonomy to BORK format
        //
        transactionStatusCd: bank.bristol.StringField? by when(this.tempVenueOrderStatus) {
            "Canceled" -> "Deleted"
            "Replaced" -> "Deleted"
            else -> "Active"
        }

        @FirstNotEmpty notionalCurrencyCode: bank.instrument.NotionalCurrencyCode?
        origCurrCdTemp: bank.orders.OrderCurrencyCode
        origCurrCd: bank.bristol.StringField? by when{
            origCurrCdTemp=null || origCurrCdTemp="" -> notionalCurrencyCode
            else -> origCurrCdTemp
        }

        // these are blank because they is blank in the BORK output
        //
        delta: bank.bristol.StringField?
        isDarkPoolOrder: bank.bristol.StringField?
        isInsidersOrder: bank.bristol.StringField?
        isSideBySide: bank.bristol.StringField?
        regionCd: bank.bristol.StringField?

        tempTradeActivityType : bank.orders.TradeActivityType?
        tradeActivityType: bank.bristol.StringField? by when {
            tempTradeActivityType = null -> "VOICE"
            else -> tempTradeActivityType
        }

        // these are blank because they are blank in the BORK output
        //
        baseDeltaVolume: bank.bristol.StringField?
        basePriceUomCd: bank.bristol.StringField?
        baseVolumeUomCd: bank.bristol.StringField?
        
        // this could be IcebergDisplaySize but ingestion model has not ingested it
        //
        tempDisplayedQuantity : bank.orders.DisplayedQuantity?
        tempDisplayedUnitQuantity : bank.orders.DisplayedUnitQuantity?
        
        displayQuantity: bank.bristol.DecimalField? by when {
            this.tempDisplayedQuantity = null  -> (tempDisplayedUnitQuantity * tempNominalValue)
            else -> tempDisplayedQuantity
        }
        
        // this is blank as we dont have the informatiuon from brokers
        //
        exchangeTradeType: bank.bristol.StringField?
        
        // these are blank because they are blank in the BORK output
        //
        localTimeZoneCd: bank.bristol.StringField?
        notionalCurrencyCd: bank.bristol.StringField?
        notionalCurrency2Cd: bank.bristol.StringField?
        
        // this is blank becuase we dont have data from brokers
        //
        orderInstructionCd: bank.bristol.StringField?

        // these are blank because they are blank in the BORK output
        //
        origCurrNotionalAmount: bank.bristol.StringField?
        origCurrNotionalAmount2: bank.bristol.StringField?
        
        // temp variable not to be output but required by when clauses
        //
        tempPriceType: bank.common.price.PriceType?

        origPriceUom: bank.bristol.StringField? by when {
            this.asset=1659 -> "Yield"
            this.asset!=217 -> "PCT"
			this.asset=217 && tempPriceType="FixedAmount" -> "CURR"
			this.asset=217 && tempPriceType!="FixedAmount" -> "PCT"
            else -> "Unknown"
        }

        // this is blank because its not in broker files
        //
        parentOrderId: bank.bristol.StringField?

        // this is blank because its blank in the BORK output
        //
        portfolioId: bank.bristol.StringField?

        // temp variable not to be output but required by when clauses
        //
        //tempQuantityType: bank.common.QuantityType?
        
        quantityUomCd: bank.bristol.StringField? by default("CURR")
        
        //quantityUomCd: bank.bristol.StringField? by when(this.tempQuantityType) {
        //    "MONE" -> "CURR"
        //    else -> tempQuantityType
        //}

        // this is blank because its blank in bork
        //
        derivedPrice: bank.bristol.StringField?

        @FirstNotEmpty puid : bank.common.ProductIdentifier?

        
        // if the isStrategy flag is true or the order is from HPC or btec 
        // then set puid to 0 so that report generator will filter it out
        //
        tempOrderMethod: bank.orders.OrderMethod?
        tempIsStrategy: bank.orders.IsStrategy?
        tempBrokerName: bank.broker.BrokerName?
        asset: bank.bristol.IntField? by when {
            this.tempIsStrategy = "TRUE" || this.tempBrokerName = "hpc" || this.tempBrokerName = "btec" -> 0
            else-> puid
        }
        
        @FirstNotEmpty instrumentId: bank.instrument.Isin?

        instrumentIdType: bank.instrument.InstrumentIdentifierType?    
        @FirstNotEmpty instrumentMaturity: bank.instrument.MaturityDateDate? (@format ="yyyy-MM-dd")
        instrumentExpiry:  bank.instrument.ExpiryDate

        temptempCumulativeQuantity : bank.orders.CumulativeQuantity?
        temptempCumulativeUnitQuantity : bank.orders.CumulativeUnitQuantity?
         
        // replaces null values by zero
        tempCumulativeQuantity : bank.bristol.DecimalField by when{
            this.temptempCumulativeQuantity = null -> 0
            else -> temptempCumulativeQuantity
        }

        // replaces null values by zero
        tempCumulativeUnitQuantity : bank.bristol.DecimalField by when{
            this.temptempCumulativeUnitQuantity = null -> 0
            else -> temptempCumulativeUnitQuantity
        }

        //checks if the cumulative quantity is null: 
        //If yes it uses the unit cumulative qty which is not null; else uses cumulative qty which is not null.
        quantityHit: bank.bristol.DecimalField? by when {
            this.temptempCumulativeQuantity = null  -> (tempCumulativeUnitQuantity * tempNominalValue)
            else -> tempCumulativeQuantity
        }

        orderMarketTime: bank.orders.OrderEventDateTime? (@format = "HH:mm:ss.SSSSSSSSS")
        
        // temp variable not to be output but required by when clauses
        //
        tempOrderStatus:bank.orders.VenueOrderStatus?

        // convert from taxonomy to BORK format
        //
        quantityStatus: bank.bristol.StringField? by when(this.tempOrderStatus) {
            "Filled" -> "Cf"
            "PartiallyFilled" -> "Pf"
            else -> "Zf"
        }

        // convert from taxonomy to BORK format
        //
        orderStatus: bank.bristol.StringField? by when(this.tempOrderStatus) {
            "Filled" -> "Cf"
            "PartiallyFilled" -> "Pf"
            "Canceled" -> "De"
            else -> "Ac"
        }

        // convert from taxonomy to BORK format
        //
        orderTradingStatus: bank.bristol.StringField? by when(this.tempVenueOrderStatus) {
            "Canceled" -> "Deleted"
            else -> "Active"
        }

        quantityNominal: bank.bristol.StringField?
        
        // this is blank because its not ingested in broker files
        //
        activityType: bank.bristol.StringField? by default("hedge")
        
        referenceInstrumentCd: bank.instrument.UnderlyingInstrumentId?

        venueOrderId: bank.orders.OrderId?

        venueIdentifier: bank.common.counterparty.CounterpartyName?    

        cusip: bank.instrument.Cusip?
    }
}
