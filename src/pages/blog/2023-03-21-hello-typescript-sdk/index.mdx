
import { michaelStone } from '@/authors';


export const meta = {
  title: 'Hello, Typescript SDK',
  description: `Using Orbital's Typescript SDK to connect APIs, DB's and Kafka`,
  date: '2023-03-21T08:00:00.000Z',
  authors: [michaelStone]
}

Hot on the heels of our [Kotlin SDK](/blog/2023-03-06-hello-kotlin-sdk/), we’re excited to release our Typescript SDK that lets you fetch data from APIs, databases and kafka topics from within your browser or Nodejs apps, without writing any integration code.

The Typescript ecosystem is close to our hearts and we're looking forward to bringing more features and examples in different web and nodejs frameworks over the next few months.


## In this post

* [Submitting TaxiQL queries](#submitting-taxiql-queries)
* [Building a DSL query](#building-a-dsl-query)
* [Providing parameters](#providing-parameters)
* [Type-safe querying](#type-safe-querying)
* [Why Orbital?](#why-orbital)
* [What's next?](#whats-next?)


## Getting Started

```bash
npm install @orbitalhq/orbital-client
```

## Usage

There’s two methods of using the SDK depending on your preferred styles. 

1. Submit a TaxiQL query string
2. Use the query DSL

For both cases, the first step is to generate a taxonomy of terms based on the schemas registered with Orbital. That's done using a script provided in the Orbital client npm package that connects to the Orbital schema server and downloads the typescript version of the taxonomy. Simply define an orbital.config.json file with the schema server URL and away you go.

The content of the taxonomy depends on the data providers that have uploaded their schemas to Orbital. There's more info available in our docs on how [schemas can be published](https://orbitalhq.com/docs/connecting-data-sources/overview).

```json
{
    "schemaServerUrl": "http://localhost:9305/"
}
```

And to run the script from your project:

```bash
npx orbital-generate
```

### Submitting TaxiQL

This method is closer to what you’d use if you’ve experimented with the Query Editor in the Orbital UI. 

```typescript
const orbitalClient = new HttpQueryClient(`http://localhost:9022`)
let films = orbitalClient.query(```
import film.types.Title
import films.FilmId

find { Film[] } as {
    id: FilmId
    title : Title
}[]
```);
```

Here, we simply send the query string over to Orbital which describes:

* the data we want to find (Films), 
* which pieces of data we want (id and title) 
* the structure we want it in (flat).

It’s worth noting that when defining the structure of data we want to receive, we can use whatever property names we want. It’s the semantic tags that we’ve imported from our generated taxonomy that are significant. In this example, `FilmId` and `Title` are the tags we've used, shown as the types of the `id` and `title` properties of our response projection. 

Check out our other content for why we're advocating for [using semantic metadata](https://orbitalhq.com/blog/2023-01-16-using-semantic-metadata) to queries and schemas. 

You can also extract the query to a separate `*.taxi` where you can take advantage of our [VSCode Taxi language plugin](https://taxilang.org/taxi-vs-code/editor-plugins/) 


### Building a DSL query

The other option is to use the DSL built in to our SDK which allows us to build our query as a series of chained functions. Just like in our query string, we’ll define the data we want, the properties we’re interested in, and the structure.

```typescript
let films = orbitalClient
    // What data do I want to find
    .find(asArray(taxonomy.film.Film))

    // Which properties do I want returned, and in what structure
    .as({
        // The property names can be whatever you want
        // The types on the right hand side are our semantic tags that describe
        // to Orbital what data to find
        id: taxonomy.film.types.FilmId,
        title: taxonomy.film.types.Title,
        provider: taxonomy.com.petflix.listings.StreamingProviderName,
        cost: taxonomy.com.petflix.listings.StreamingProviderPrice
    })
    .execute()
    .subscribe()
```


### Providing parameters

Sometimes we want to be more specific about the data we’re fetching. Instead of ALL the films, maybe we want more detailed information about one film. 

It’s worth mentioning here a design consideration of Orbital. We make consuming your existing APIs and data sources much easier, but we work with what you’ve got. So for example if you only define an endpoint which returns all the films, that’s what you can query with Orbital. 

You probably do have a getter for individual items, and that’s where this feature of the SDK comes in handy. 

We’ll add an extra function call `given()`, using the semantic tag of the item we’re specifying, the film ID. 


```typescript
let film = orbitalClient
    // Return the data for the film with a FilmId of "5"
    .given(taxonomy.film.types.FilmId, "5")
    .find(asArray(taxonomy.film.Film))
    .as({
        id: taxonomy.film.types.FilmId,
        title: taxonomy.film.types.Title,
        provider: taxonomy.com.petflix.listings.StreamingProviderName,
        cost: taxonomy.com.petflix.listings.StreamingProviderPrice
    })
    .execute()
    .subscribe()
```


## Type-safe querying

A big advantage from using the DSL is type safe querying of our data. For whatever property names and structure we specify in our `as()` block, the responses from Orbital will be correctly typed.

That’s significant because instead of making a request to a service and providing a type parameter based on what the response *should* be, we’re asking Orbital to fetch specific data and return it in a specific structure. There's a direct link between the types  we're asking for from Orbital and how the data will be returned. Additionally, the response type of our query is set of our specific object, not typed as `any`.

For example, if I add in explicit types to the variable we're assigning our response to, we'll see that the Typescript compiler won't raise any concerns.

```typescript

let films: Observable<{
    'id': number,
    'title': string,
    'provider': string,
    'cost': number
}> = orbitalClient
    .find(asArray(taxonomy.film.Film))
    .as({
        id: taxonomy.film.types.FilmId,
        title: taxonomy.film.types.Title,
        provider: taxonomy.com.petflix.listings.StreamingProviderName,
        cost: taxonomy.com.petflix.listings.StreamingProviderPrice
    })
    .execute()
```

## Why Orbital?

We think there’s some great ergonomics here for Typescript developers when fetching data. There’s also a bunch of other benefits you get from using Orbital to power your Typescript apps:

* Adapt to schema changes - your code will automatically adapt to changes in schemas
* Eliminate integration code - you’ll eliminate loads of integration code and code-gen of other teams schemas
* Consumer defined schemas - regardless of the tech used by other teams you’ll gain the power to pick and choose which data is delivered to you.
* Observability - see exactly how an integration was performed in the Orbital console, including response payloads and cell level lineage

Check out our [docs](https://orbitalhq.com/docs) for more information.

## What's next?

In terms of where we’re heading, there’s a number of exciting features we’ll be adding in the near future. They’re already available in the core platform, and we’ll be adding support for them in the Typescript SDK.

* Streaming query results - for larger result sets, start receiving responses as a stream as soon as the first results become available
* Subscriptions - connect to kafka topics and other streaming sources of data
* Publishing schemas from Nodejs apps - similar to the capability in our Kotlin SDK, this let’s publishers add a couple of decorators to their code to push their schemas up to Orbital
* Type safety for projections to nested data structures - query projections for the DSL are currently limited to flat objects. While the Orbital query runner is capable of returning results in any shape requested in the query string, the DSL option in the SDK isn’t able to provide type safety for nested structures.
