import WhatClientsSee from './what-clients-sees.png'; import {ImageWithCaption} from "@/components/ImageWithCaption";
export const meta = {
   title: 'Overview',
   description: 'Vyne automates API integration, and provides rich data discovery, so you can spend less time plumbing, and more time building.'
}

## Introduction
Modern organisations have multiple services and data sources - and with the move to microservices, 
this is on the rise. 

However, while microservices are great, lots of services means lots of plumbing - which can quickly become
brittle, making change difficult.

Orbital addresses this by automatically building and maintaining the integration between services, 
allowing services to stay decoupled from one another.

### Consumer-centric integration
Orbital allows consumers to ask for the data they need, without specifying how to fetch it.  Oribtal generates the integration on-the-fly, using [Taxi](https://taxilang.org)
metadata embedded inside API specs.

This means that as API's evolve, or as services are deployed or replaced, Orbital's integrations automatically adapt, without requiring clients to change.

![Vyne provides automated API orchestration](/assets/documentation-images.png)


```taxi
given {
   emailAddress : EmailAddress = "jimmy@demo.com"
} find {
   lastPurchase: {
      @Format("dd/MMM/yyyy hh:mm:ss")
      date : LastPurchaseDate
      value : LastPurchaseValue
   }
   accountBalance : AccountBalance
}
```

Orbital leverages schemas to automatically work out which services to call, 
and sequences them together to pass data from service to service, in order to discover the data clients need.

<ImageWithCaption src={WhatClientsSee.src} />

## Integration that adapts with you

Services publish their schemas to Orbital, which describe their API's and the data they provide. 

Orbital uses this to build integration plans on-the-fly. This means that as your API's change, Orbital automatically adapts, 
keeping clients protected from the change. 

There's no resolvers to update, Swagger SDK's to rebuild, or API consumer contracts to refactor.

Orbital provides several ways for services to generate and publish their schema - 
hand-crafted schema's, automatically generated at runtime, git backed in a central repository, or a mix of the three.

Find out more about schema strategies [here](/docs/publishing-and-sharing-schemas)


## Semantic data schemas

Legacy integration approaches have relied on mapping field names between services and models in order to pass information from place-to-place.

This is brittle, laborious work. It has to be repeated for every service pair - for example, mapping the `CustomerApi` to the `BalancesApi` has to be repeated when mapping the `CustomerApi` to the `MarketingApi`, etc.\)

This field mapping takes place because traditional schemas don't provide rich enough information to link on anything else. If a field gets renamed?  ðŸ’¥ Boom! Breakdown city.

![Without Vyne, data is manually mapped based on field names. Ergh.](/assets/without-vyne.png)

Vyne is different. It uses Taxi to build a semantic representation of API's and data. This means that Vyne can understand how data relates from one service to another, between model to model, regardless of how it's named.

Once you've tagged field as having a `CustomerId` \(irrespective of the name assigned to the field\), Vyne instantly knows how to leverage that data on all other services that take a `CustomerId`. This means significantly less mapping work.

![With Vyne, data is automatically mapped, based on the information it contains \(it&apos;s &quot;Semanitc Type&quot;\)](/assets/documentation-images-1-.png)

This also means that developers are free to leverage whatever domain model that works for them, avoiding the dreaded "Enterprise Domain Model". Vyne understands how to map the data on-the-fly, avoiding all the getter-to-setter mapping that used to take place.

Find out more about Semantic data and Taxi on the  [Taxi website](https://taxilang.org)
