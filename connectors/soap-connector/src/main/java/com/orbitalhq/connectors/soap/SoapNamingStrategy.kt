package com.orbitalhq.connectors.soap

import com.fasterxml.jackson.databind.PropertyNamingStrategy
import com.fasterxml.jackson.databind.cfg.MapperConfig
import com.fasterxml.jackson.databind.introspect.AnnotatedField
import com.fasterxml.jackson.databind.introspect.AnnotatedMember
import com.fasterxml.jackson.databind.introspect.AnnotatedMethod
import com.orbitalhq.schemas.Schema
import jakarta.xml.bind.annotation.XmlType

/**
 * A naming strategy for matching fields on inbound SOAP objects back to the name
 * they were declared in the WSDL.
 *
 * By the time we get a response back, property names have been converted multiple times.
 *
 * The Taxi spec aligns with the WSDL.  Unfortunately, the property names have Java Bean convention
 * applied to them - twice. (Once from wsdl element name -> Java field name, then Java Field name -> Java Method Name).
 * This means that even the autogenerated property names annotated on the class don't match for edge cases. (eg:
 * sISOCode becomes sisoCode or sIsoCode).
 *
 * The only way to solve this (that I've found) is provide the schema, and try to match
 * back to the property name.
 *
 * This wouldn't work if:
 *  * We can't find the type in the schema (note - we don't have access to the namespace, just the type name.
 *    Suspect I can fix this though - isn't the namespace in the Client instance below?
 *  * We match on field name case insensitive.  This won't work if there are two fields with the sane name, different casing.
 *
 *  This is also arguably slow (although I havne't profiled it), and requires a standalone ObjectMapper, so
 *  lots of object allocation going on.
 */
class SoapNamingStrategy(private val schema: Schema) : PropertyNamingStrategy() {
   override fun nameForField(config: MapperConfig<*>?, field: AnnotatedField?, defaultName: String?): String {
      return super.nameForField(config, field, defaultName)
   }

   override fun nameForSetterMethod(config: MapperConfig<*>?, method: AnnotatedMethod?, defaultName: String?): String {
      return super.nameForSetterMethod(config, method, defaultName)
   }

   override fun nameForGetterMethod(config: MapperConfig<*>?, method: AnnotatedMethod, defaultName: String): String {
      return findXmlElementName(method, defaultName) ?: defaultName
   }

   private fun findXmlElementName(member: AnnotatedMember, defaultName: String): String? {
      val xmlTypeAnnotation = member.declaringClass.getAnnotation(XmlType::class.java) ?: return null
      // First pass, try and match on the type in the schema.
      if (schema.hasType(xmlTypeAnnotation.name)) {
         val type = schema.type(xmlTypeAnnotation.name)
         val matchingKey = type.attributes.keys.singleOrNull { it.lowercase() == defaultName.lowercase() }
         if (matchingKey != null) {
            return matchingKey
         }
      }

      val declaredPropertyNames = xmlTypeAnnotation.propOrder
      val match = declaredPropertyNames.singleOrNull { p -> p.lowercase() == defaultName.lowercase() }
      return match
   }
}
