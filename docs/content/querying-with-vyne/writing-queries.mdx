---
title: Querying with Vyne
description: Submitting queries to Vyne's API to discover data
---

import {Hint} from "../components/hint";

Vyne focuses on querying for data based on it's meaning, rather than which system provides it. This allows services to
change, and data to move, without requiring consumers to update their queries.

![diagram](querying.png)

## Writing queries

Queries are written in [TaxiQL](https://docs.taxilang.org/language-reference/querying-with-taxiql/), an open source
query language for data.

<Hint>

   [TaxiQL](https://docs.taxilang.org/language-reference/querying-with-taxiql/) is a great query language.

   The taxi documentation has details on the syntax, which we haven't duplicated here.  Go check it out, then come back.

   We'll wait.

</Hint>

TaxiQL is agnostic of where data comes from - it's left to Vyne to discover data from the various sources that have been
connected.

Here's some sample queries:

```
// Find all the movies
find { Movie[] }

// Find all the movies, enriching and projecting them to a different structure
find { Movie[] } as {
   title : MovieTitle
   director : DirectorName
   rating : RottenTomatoesScore
}[]
```

## Projections
Projections are a way of taking data from one place, then transforming & combining it with other data sources.

Vyne uses the information present on the object being projected in order to call services and find other information.

eg:

```
model Purchase {
   transactionId : TransactionId
   customerId : CustomerId
}

find { Purchases[] }
as {
  // Projections let you change field names, and reshape objects as required
  txn: TransactionId
  // Not present on the original Purchase object, so try to
  // find it using something we already know (in this case, the CustomerId)
  customerName: CustomerName
}
```

### Data discovery rules
When projecting, Vyne will use information present on the source object to discover data
on the target object.

Data can be discovered transitively, combining multiple sources.

#### Operations with @Id fields on return types
If the result of an operation is an object that exposes an `@Id` field, then only operations which accept that `@Id` field as
an input will be called.

eg:

```
model Customer {
  @Id customerId : CustomerId
  name : CustomerName
}

service CustomerService {
   // Can be called when projecting, because
   // Person has an @Id of type PersonId
   findCustomer(CustomerId):Customer

   // Cannot be called when projecting, because
   // Person has an @Id, and it isn't PersonName
   findCustomerByName(CustomerName):Customer
}
```

#### Operations without @Id fields on return types
If the result of an operation is an object that *does not* expose an `@Id` field, then it can be called with
any information available.




### Filling in the gaps with `@FirstNotEmpty`

### Understanding how Vyne discovers data
TODO

## Expressions in queries
Taxi allows the definition of expressions on both [types](https://docs.taxilang.org/language-reference/advanced-types/#expression-types) and [fields](https://docs.taxilang.org/language-reference/advanced-types/#expression-on-fields), but doesn't
provide an evaluation engine - that's where Vyne comes in.

Typically, expressions are used in a projection within a query.

You can also use them on a model to expose derived information when a model is parsed by Vyne (eg., when
return from a service) - but that's less common.  So, while documentation here focuses on query projections,
you can do everything here on a model too.

### Writing an expression in a projection
Expressions can be defined in the fields of a projected result from a query:

```taxi
find { Flights[] }
as {
  flightNumber : FlightNumber
  totalSeatsAvailable : TotalSeats
  soldSeats : SoldSeats
  remainingSeats : Int by (this.totalSeatsAvailable - this.soldSeats)
}
```

Expressions can be defined in two ways - on a field, or on a type.

#### Expressions on a field
```
// Expression types on a field:
find { Flights[] }
as {
  flightNumber : FlightNumber
  totalSeatsAvailable : TotalSeats
  soldSeats : SoldSeats
  // field expressions can be defined EITHER using field references...
  remainingSeats : Int by (this.totalSeatsAvailable - this.soldSeats)
  // ...or type references...
  remainingSeats : Int by (TotalSeats - SoldSeats)
}
```
#### Expressions on a type
To encapsulate common expressions, you can define a type with the expression:

```taxi
// Expression type:
type RemainingSeats by TotalSeats - SoldSeats

// Which is then used on a projection:
find { Flights[] }
as {
  flightNumber : FlightNumber
  totalSeatsAvailable : TotalSeats
  soldSeats : SoldSeats
  remainingSeats : RemainingSeats
}
```

Unlike field expressions, type expression cannot use field names, and can only reference other types.

#### How Vyne discovers values to evaluate expressions
When Vyne is evaluating an expression, it first looks on the source object being projected
for the input values into the expression.

If any inputs are not available, then Vyne will perform a search using the current data available on
the source object in an attempt to look up the value.


## Submitting queries

### Rest API

Queries to Vyne are submitted to the `/api/taxiql` endpoint:

```
curl 'https://localhost:9022/api/taxiql' \
  -H 'Content-Type: application/taxiql' \
  --data-raw 'find { Movie[] }'
```

#### A word about content type

Strictly speaking, the content type for taxiql queries is `application/taxiql`. However, the Vyne server will accept
taxiql queries with any of the following content types headers:

* `Content-Type: application/json`
* `Content-Type: application/taxiql`
* `Content-Type: text/plain`

This is to allow broad compatability with clients.

### Large queries with Server Sent Events

Running large queries can result in out-of-memory errors if Vyne is holding the result set in memory.

To address this, Vyne supports pushing results over server-sent-events. To consume a query as a server-sent-event, set
the `Accept` header to `text/event-stream`:

```
curl 'http://localhost:9022/api/taxiql' \
  -H 'Accept: text/event-stream' \
  -H 'Content-Type: application/taxiql' \
  --data-raw 'find { Movie[] }'
```

Results are pushed out from Vyne as they are available.

### Including type metadata in responses

Vyne can include type metadata in the responses being sent back.

To enable this, append  `?resultMode=TYPED` to the API call:

```
curl 'http://localhost:9022/api/taxiql?resultMode=TYPED' \
  -H 'Accept: text/event-stream' \
  -H 'Content-Type: application/taxiql' \
  --data-raw 'find { Movie[] }'
```

